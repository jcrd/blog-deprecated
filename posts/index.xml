<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on twiddling bits</title><link>https://twiddlingbits.net/posts/</link><description>Recent content in Posts on twiddling bits</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 15 May 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://twiddlingbits.net/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Debug logging in Go</title><link>https://twiddlingbits.net/debug-logging-in-go/</link><pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate><guid>https://twiddlingbits.net/debug-logging-in-go/</guid><description>&lt;p>My project, &lt;a href="https://github.com/jcrd/lifelight">lifelight&lt;/a>, is written in Go and designed to run on
low-powered &lt;a href="https://www.raspberrypi.com/products/raspberry-pi-zero/">Raspberry Pis&lt;/a>. I wanted minimal overhead in the production
build, so I implemented a logging system that is compiled out in non-debug
builds. This is made easy using Go&amp;rsquo;s &lt;a href="https://pkg.go.dev/go/build#hdr-Build_Constraints">&lt;em>build constraints&lt;/em>&lt;/a>.&lt;/p></description></item><item><title>luarocket, or vendoring Lua rocks</title><link>https://twiddlingbits.net/luarocket-or-vendoring-lua-rocks/</link><pubDate>Sun, 24 Apr 2022 00:00:00 +0000</pubDate><guid>https://twiddlingbits.net/luarocket-or-vendoring-lua-rocks/</guid><description>&lt;p>The Lua programming language, like many others, employs a purpose-built package
manager to download and install its ecosystem of libraries. This tool,
&lt;a href="https://luarocks.org/">LuaRocks&lt;/a>, has some notable features:&lt;/p>
&lt;ul>
&lt;li>downloads/installs packages to user-specific or system-wide locations&lt;/li>
&lt;li>configurable dependency resolution&lt;/li>
&lt;li>builds locally define rocks (Lua modules packaged by LuaRocks)&lt;/li>
&lt;li>queries information about the active LuaRocks configuration&lt;/li>
&lt;/ul>
&lt;p>In these ways, LuaRocks is functionally similar to the package managers of other
dynamic languages such as &lt;a href="https://pip.pypa.io/en/stable/">pip&lt;/a> for Python and &lt;a href="https://www.npmjs.com/">npm&lt;/a> for JavaScript.&lt;/p></description></item><item><title>From Pod to man</title><link>https://twiddlingbits.net/from-pod-to-man/</link><pubDate>Sun, 30 Jan 2022 00:00:00 +0000</pubDate><guid>https://twiddlingbits.net/from-pod-to-man/</guid><description>&lt;p>While developing many of my projects I&amp;rsquo;ve found myself faced with the timeless
question: to document or not to document? My goal is to provide &lt;a href="https://en.wikipedia.org/wiki/Man_page">man
pages&lt;/a> for any project used from the command-line or designed to be
integrated into a larger Linux ecosystem. And so, at the onset of my open-source
journey, I stood at a crossroad: learn the unwieldy &lt;a href="https://en.wikipedia.org/wiki/Troff">troff&lt;/a> format of man
pages or set up a process to build them from an alternative markup format.&lt;/p></description></item><item><title>Debouncing with a custom GSource</title><link>https://twiddlingbits.net/debouncing-with-a-custom-gsource/</link><pubDate>Tue, 13 Apr 2021 00:00:00 +0000</pubDate><guid>https://twiddlingbits.net/debouncing-with-a-custom-gsource/</guid><description>&lt;p>While developing &lt;a href="https://twiddlingbits.net/introducing-sessiond/">sessiond&lt;/a>, a session manager written in C with
&lt;a href="https://docs.gtk.org/glib/">GLib&lt;/a>, I was presented with an ideal use case for debouncing: postponing
the execution of code that would otherwise run too frequently based on the
influx of external events. sessiond is responsible for monitoring X11 input
events, which are processed in the GLib event loop using a custom
&lt;a href="https://docs.gtk.org/glib/struct.Source.html">GSource&lt;/a>. Debouncing avoids unnecessarily handling every event,
especially mouse input events which are generated constantly while the mouse
pointer moves.&lt;/p></description></item><item><title>Introducing sessiond</title><link>https://twiddlingbits.net/introducing-sessiond/</link><pubDate>Sun, 04 Apr 2021 00:00:00 +0000</pubDate><guid>https://twiddlingbits.net/introducing-sessiond/</guid><description>&lt;p>When I began using Linux on the desktop in ~2012, I experimented with the
prevalent desktop environments (Gnome, KDE, etc.), but was quickly drawn into
the realm of tiling window managers by their promise of increased productivity
and customization. While I believe these promises were fulfilled, tiling window
managers were not without a significant shortcoming: they are solely window
managers, lacking the integrated suite of software and applications that put the
environment in desktop environments.&lt;/p></description></item></channel></rss>