<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="bits of blogging"><meta name="generator" content="Eleventy"><link rel="icon" href="/favicon.ico"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><title>Debouncing with a custom GSource</title><link rel="stylesheet" href="/site.css"><link rel="stylesheet" href="/prism-one-dark.css"></head><body class="flex flex-col min-h-screen mx-6 md:mx-auto my-auto max-w-2xl"><main class="flex-grow pt-6 md:pt-12"><div class="flex flex-col md-960:flex-row"><div class="mb-4 md-960:-ml-32 md-960:mr-8"><a href="https://twiddlingbits.net/"><img src="https://www.gravatar.com/avatar/6dd0c8e5214e4c4d0f0dafabebe82c3d?size=96"></a></div><div class="pt-4"><article class="space-y-24"><div class="flex flex-col gap-y-5"><h1 class="text-4xl font-bold">Debouncing with a custom GSource</h1><div class="flex gap-x-2 text-gray-400"><div class="flex gap-x-1">Last updated: <span class="italic">Apr 13, 2021</span></div>&bull;<div class="flex gap-x-1"><span>4 min </span>read</div></div></div><div class="prose"><p>While developing <a href="https://twiddlingbits.net/introducing-sessiond/">sessiond</a>, a session manager written in C with <a href="https://docs.gtk.org/glib/">GLib</a>, I was presented with an ideal use case for debouncing: postponing the execution of code that would otherwise run too frequently based on the influx of external events. sessiond is responsible for monitoring X11 input events, which are processed in the GLib event loop using a custom <a href="https://docs.gtk.org/glib/struct.Source.html">GSource</a>. Debouncing avoids unnecessarily handling every event, especially mouse input events which are generated constantly while the mouse pointer moves.</p><h2>Abstract debouncing</h2><p>In the case of sessiond, only the time an input event occurred is relevant, so an abstract implementation of debouncing might look like this:</p><pre class="language-python"><code class="language-python">debounce_interval <span class="token operator">=</span> <span class="token number">1</span><br><br><span class="token comment"># Called when time given to `schedule_event_processing` is reached.</span><br><span class="token keyword">def</span> <span class="token function">process_event</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><br>    <span class="token keyword">if</span> current_time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> last_event_time <span class="token operator">>=</span> debounce_interval<span class="token punctuation">:</span><br>        process<span class="token punctuation">(</span><span class="token punctuation">)</span><br><br><span class="token keyword">while</span> true<span class="token punctuation">:</span><br>    <span class="token keyword">if</span> event<span class="token punctuation">:</span><br>        last_event_time <span class="token operator">=</span> current_time<span class="token punctuation">(</span><span class="token punctuation">)</span><br>        schedule_event_processing<span class="token punctuation">(</span>process_event<span class="token punctuation">,</span><br>          last_event_time <span class="token operator">+</span> debounce_interval<span class="token punctuation">)</span></code></pre><p>When an event occurs, the current time is recorded as <code>last_event_time</code>. There should be no response to the event until at least <code>debounce_interval</code> has elapsed, so event processing is scheduled for a time in the future equal to the current time plus the debounce interval. If another event occurs before this time has passed, an additional response is scheduled, and <code>last_event_time</code> is updated.</p><p>In the processing function, it is important to compare the time that has elapsed since the last event to <code>debounce_interval</code> to ensure additional events were not generated after this response was scheduled. This way, event processing happens only when <code>debounce_interval</code> time has passed since the last event was received—the essence of debouncing.</p><h2>Custom GSource implementation</h2><p>This method of debouncing can be implemented with a custom GSource's <code>check</code> and <code>dispatch</code> functions using <a href="https://docs.gtk.org/glib/method.Source.set_ready_time.html">g_source_set_ready_time</a>.</p><p>First, define a custom GSource by declaring a struct containing a <code>GSource</code>:</p><pre class="language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span><br>    GSource source<span class="token punctuation">;</span><br>    gpointer fd<span class="token punctuation">;</span><br>    gint64 last_event_time<span class="token punctuation">;</span><br><span class="token punctuation">}</span> InputSource<span class="token punctuation">;</span></code></pre><p>Next, implement the <code>check</code> function, which determines if the source is ready to be dispatched:</p><pre class="language-c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEBOUNCE_US</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> <span class="token number">1000000</span><span class="token punctuation">)</span></span></span><br><br>gboolean<br><span class="token function">inputsource_check</span><span class="token punctuation">(</span>GSource <span class="token operator">*</span>source<span class="token punctuation">)</span><br><span class="token punctuation">{</span><br>    InputSource <span class="token operator">*</span>self <span class="token operator">=</span> <span class="token punctuation">(</span>InputSource <span class="token operator">*</span><span class="token punctuation">)</span>source<span class="token punctuation">;</span><br>    GIOCondition revents <span class="token operator">=</span> <span class="token function">g_source_query_unix_fd</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> self<span class="token operator">-></span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>revents <span class="token operator">&amp;</span> G_IO_IN<span class="token punctuation">)</span><span class="token punctuation">)</span><br>        <span class="token keyword">return</span> FALSE<span class="token punctuation">;</span><br><br>    <span class="token comment">// Process events...</span><br><br>    self<span class="token operator">-></span>last_event_time <span class="token operator">=</span> <span class="token function">g_get_monotonic_time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token function">g_source_set_ready_time</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> self<span class="token operator">-></span>last_event_time <span class="token operator">+</span> DEBOUNCE_US<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>In this function, a file descriptor is queried to determine if any events are pending. If there are no events to be handled, the function returns <code>FALSE</code> to signify there is no need to call the <code>dispatch</code> function. Otherwise, pending events should be processed accordingly. Finally, the current monotonic time—being that of the last event(s)—is recorded and the source is instructed to dispatch in <code>DEBOUNCE_US</code> microseconds with <code>g_source_set_ready_time</code>.</p><p>Now, implement the <code>dispatch</code> function, which is responsible for calling the callback function provided to this GSource at creation time:</p><pre class="language-c"><code class="language-c">gboolean<br><span class="token function">inputsource_dispatch</span><span class="token punctuation">(</span>GSource <span class="token operator">*</span>source<span class="token punctuation">,</span> GSourceFunc func<span class="token punctuation">,</span> gpointer user_data<span class="token punctuation">)</span><br><span class="token punctuation">{</span><br>    XSource <span class="token operator">*</span>self <span class="token operator">=</span> <span class="token punctuation">(</span>XSource <span class="token operator">*</span><span class="token punctuation">)</span>source<span class="token punctuation">;</span><br><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">g_get_monotonic_time</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> self<span class="token operator">-></span>last_event_time <span class="token operator">>=</span> DEBOUNCE_US<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token function">g_source_set_ready_time</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span>user_data<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token keyword">return</span> G_SOURCE_CONTINUE<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>The logic here is as follows: this function is called at the monotonic time given to <code>g_source_set_ready_time</code> in the <code>check</code> function above, so we know at least <code>DEBOUNCE_US</code> time has passed since the handling of <em>those</em> events, <strong>but</strong> additional events may have been received in the meantime, reflected by an updated <code>self-&gt;last_event_time</code>. If at least <code>DEBOUNCE_US</code> time has elapsed since the last event, we call the user-provided callback function, and <code>g_source_set_ready_time(source, -1)</code> is used to stop future dispatching of this source until the <code>check</code> function detects pending events. This is necessary because <code>g_source_set_ready_time</code> will cause the source to be continuously dispatched if the time it was last given is in the past, which will inevitably be the case.</p><p>Finally, create the <code>GSourceFuncs</code> struct and initialize the custom GSource:</p><pre class="language-c"><code class="language-c">GSourceFuncs inputsource_funcs <span class="token operator">=</span> <span class="token punctuation">{</span><br>    <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token comment">// prepare function</span><br>    inputsource_check<span class="token punctuation">,</span><br>    inputsource_dispatch<span class="token punctuation">,</span><br>    <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token comment">// finalize function</span><br>    <span class="token constant">NULL</span><span class="token punctuation">,</span><br>    <span class="token constant">NULL</span><span class="token punctuation">,</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br>GSource <span class="token operator">*</span>source <span class="token operator">=</span> <span class="token function">g_source_new</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>inputsource_funcs<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>InputSource<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>InputSource <span class="token operator">*</span>self <span class="token operator">=</span> <span class="token punctuation">(</span>InputSource <span class="token operator">*</span><span class="token punctuation">)</span>source<span class="token punctuation">;</span><br><br>self<span class="token operator">-></span>last_event_time <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br><br><span class="token comment">// Add the file descriptor.</span><br><span class="token comment">// self->fd = g_source_add_unix_fd(source, ..., G_IO_IN);</span><br><br><span class="token comment">// Set callback.</span><br><span class="token comment">// g_source_set_callback(source, ...);</span><br><br><span class="token comment">// Attach source to context.</span><br><span class="token comment">// g_source_attach(source, ...);</span></code></pre><h2>More information</h2><p><a href="https://web.archive.org/web/20200806195500/https://developer.gnome.org/gnome-devel-demos/unstable/custom-gsource.c.html.en">This tutorial</a> describes in greater detail the <code>check</code>, <code>dispatch</code>, and other functions that control the behavior of a custom GSource.</p><p>For a complete working example, refer to sessiond's debouncing implementation in <a href="https://github.com/jcrd/sessiond/blob/master/src/xsource.c">xsource.c</a>.</p></div></article></div></div></main><footer class="flex gap-x-1 py-10"><p class="text-gray-500">&nbsp;&copy; 2022</p><a class="hover:underline" href="https://twiddlingbits.net/">James Reed</a></footer></body></html>