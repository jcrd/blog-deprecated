<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>development on twiddling bits</title><link>https://twiddlingbits.net/tags/development/</link><description>Recent content in development on twiddling bits</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 15 May 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://twiddlingbits.net/tags/development/index.xml" rel="self" type="application/rss+xml"/><item><title>Debug logging in Go</title><link>https://twiddlingbits.net/debug-logging-in-go/</link><pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate><guid>https://twiddlingbits.net/debug-logging-in-go/</guid><description>My project, lifelight, is written in Go and designed to run on low-powered Raspberry Pis. I wanted minimal overhead in the production build, so I implemented a logging system that is compiled out in non-debug builds. This is made easy using Go&amp;rsquo;s build constraints.
The code This implementation utilizes three files: the main file, and two logger implementation files with build constraints.
The main file includes the interface definition and a global variable:</description></item><item><title>luarocket, or vendoring Lua rocks</title><link>https://twiddlingbits.net/luarocket-or-vendoring-lua-rocks/</link><pubDate>Sun, 24 Apr 2022 00:00:00 +0000</pubDate><guid>https://twiddlingbits.net/luarocket-or-vendoring-lua-rocks/</guid><description>The Lua programming language, like many others, employs a purpose-built package manager to download and install its ecosystem of libraries. This tool, LuaRocks, has some notable features:
downloads/installs packages to user-specific or system-wide locations configurable dependency resolution builds locally define rocks (Lua modules packaged by LuaRocks) queries information about the active LuaRocks configuration In these ways, LuaRocks is functionally similar to the package managers of other dynamic languages such as pip for Python and npm for JavaScript.</description></item><item><title>From Pod to man</title><link>https://twiddlingbits.net/from-pod-to-man/</link><pubDate>Sun, 30 Jan 2022 00:00:00 +0000</pubDate><guid>https://twiddlingbits.net/from-pod-to-man/</guid><description>While developing many of my projects I&amp;rsquo;ve found myself faced with the timeless question: to document or not to document? My goal is to provide man pages for any project used from the command-line or designed to be integrated into a larger Linux ecosystem. And so, at the onset of my open-source journey, I stood at a crossroad: learn the unwieldy troff format of man pages or set up a process to build them from an alternative markup format.</description></item><item><title>Debouncing with a custom GSource</title><link>https://twiddlingbits.net/debouncing-with-a-custom-gsource/</link><pubDate>Tue, 13 Apr 2021 00:00:00 +0000</pubDate><guid>https://twiddlingbits.net/debouncing-with-a-custom-gsource/</guid><description>While developing sessiond, a session manager written in C with GLib, I was presented with an ideal use case for debouncing: postponing the execution of code that would otherwise run too frequently based on the influx of external events. sessiond is responsible for monitoring X11 input events, which are processed in the GLib event loop using a custom GSource. Debouncing avoids unnecessarily handling every event, especially mouse input events which are generated constantly while the mouse pointer moves.</description></item></channel></rss>